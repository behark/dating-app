const {
  sendSuccess,
  sendError,
  sendValidationError,
  sendNotFound,
  sendUnauthorized,
  sendForbidden,
  sendRateLimit,
  asyncHandler,
} = require('../../shared/utils/responseHelpers');
const Message = require('../../core/domain/Message');
const { logger } = require('../../infrastructure/external/LoggingService');

const User = require('../../core/domain/User');

const UserActivity = require('../../core/domain/UserActivity');

/**
 * Send a GIF message
 */
const sendGifMessage = async (req, res) => {
  try {
    const { matchId, gifUrl, gifId, gifMetadata } = req.body;
    const senderId = req.user.id;

    if (!matchId || !gifUrl) {
      return sendError(res, 400, { message: 'matchId and gifUrl are required' });
    }

    // Create message
    const message = new Message({
      matchId,
      senderId,
      receiverId: null, // Will be populated from match data
      type: 'gif',
      content: 'Sent a GIF',
      mediaUrl: gifUrl,
      mediaMetadata: {
        gifId,
        ...gifMetadata,
      },
    });

    await message.save();

    // Log activity
    await UserActivity.logActivity(senderId, 'message', {
      matchId,
      messageType: 'gif',
    });

    return sendSuccess(res, 201, { message: 'GIF sent successfully', data: message });
  } catch (/** @type {any} */ error) {
    logger.error('Error sending GIF:', { error: error.message, stack: error.stack });
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : String(error),
    });
  }
};

/**
 * Send a sticker message
 */
const sendStickerMessage = async (req, res) => {
  try {
    const { matchId, stickerUrl, stickerPackId, stickerId } = req.body;
    const senderId = req.user.id;

    if (!matchId || !stickerUrl) {
      return sendError(res, 400, { message: 'matchId and stickerUrl are required' });
    }

    // Create message
    const message = new Message({
      matchId,
      senderId,
      receiverId: null,
      type: 'sticker',
      content: 'Sent a sticker',
      mediaUrl: stickerUrl,
      mediaMetadata: {
        stickerPackId,
        stickerId,
      },
    });

    await message.save();

    // Log activity
    await UserActivity.logActivity(senderId, 'message', {
      matchId,
      messageType: 'sticker',
    });

    return sendSuccess(res, 201, { message: 'Sticker sent successfully', data: message });
  } catch (/** @type {any} */ error) {
    logger.error('Error sending sticker:', { error: error.message, stack: error.stack });
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : String(error),
    });
  }
};

/**
 * Send a voice message
 */
const sendVoiceMessage = async (req, res) => {
  try {
    const { matchId, voiceUrl, duration, language = 'en' } = req.body;
    const senderId = req.user.id;

    if (!matchId || !voiceUrl || !duration) {
      return sendError(res, 400, { message: 'matchId, voiceUrl, and duration are required' });
    }

    if (duration < 1 || duration > 300) {
      return sendError(res, 400, {
        message: 'Voice message duration must be between 1 and 300 seconds',
      });
    }

    // Create message
    const message = new Message({
      matchId,
      senderId,
      receiverId: null,
      type: 'voice',
      content: `Voice message (${Math.round(duration)}s)`,
      mediaUrl: voiceUrl,
      voiceMessage: {
        duration,
        language,
        isTranscribed: false,
      },
    });

    await message.save();

    // Log activity
    await UserActivity.logActivity(senderId, 'message', {
      matchId,
      messageType: 'voice',
      duration,
    });

    return sendSuccess(res, 201, { message: 'Voice message sent successfully', data: message });
  } catch (/** @type {any} */ error) {
    logger.error('Error sending voice message:', { error: error.message, stack: error.stack });
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : String(error),
    });
  }
};

/**
 * Transcribe voice message (AI integration)
 */
const transcribeVoiceMessage = async (req, res) => {
  try {
    const { messageId } = req.body;

    const message = await Message.findById(messageId);
    if (!message) {
      return res.status(404).json({
        success: false,
        message: 'Message not found',
      });
    }

    if (!message || message.type !== 'voice') {
      return res.status(404).json({
        success: false,
        message: 'Voice message not found',
      });
    }

    if (!message.voiceMessage) {
      return sendError(res, 400, { message: 'Message does not have a voice message' });
    }

    // In production, integrate with speech-to-text API (Google Cloud Speech, Azure Speech, etc.)
    // For now, return placeholder
    const transcript = '[Transcription would be generated by AI service]';

    message.voiceMessage.transcript = transcript;
    message.voiceMessage.isTranscribed = true;
    await message.save();

    return res.status(200).json({
      success: true,
      message: 'Voice message transcribed',
      data: {
        transcript,
        language: message.voiceMessage.language,
      },
    });
  } catch (/** @type {any} */ error) {
    logger.error('Error transcribing voice message:', { error: error.message, stack: error.stack });
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : String(error),
    });
  }
};

/**
 * Initiate video call
 */
const initiateVideoCall = async (req, res) => {
  try {
    const { matchId, callId } = req.body;
    const initiatorId = req.user.id;

    if (!matchId || !callId) {
      return sendError(res, 400, { message: 'matchId and callId are required' });
    }

    // Create video call message
    const message = new Message({
      matchId,
      senderId: initiatorId,
      receiverId: null,
      type: 'video_call',
      content: 'Initiated a video call',
      videoCall: {
        callId,
        initiatedBy: initiatorId,
        status: 'pending',
      },
    });

    await message.save();

    // Log activity
    await UserActivity.logActivity(initiatorId, 'video_call', {
      matchId,
      callId,
      status: 'initiated',
    });

    return res.status(201).json({
      success: true,
      message: 'Video call initiated',
      data: {
        messageId: message._id,
        callId,
        status: 'pending',
      },
    });
  } catch (/** @type {any} */ error) {
    logger.error('Error initiating video call:', { error: error.message, stack: error.stack });
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : String(error),
    });
  }
};

/**
 * Update video call status
 */
const updateVideoCallStatus = async (req, res) => {
  try {
    const { messageId, status, duration } = req.body;

    if (!messageId || !status) {
      return sendError(res, 400, { message: 'messageId and status are required' });
    }

    if (!['accepted', 'declined', 'missed', 'ended'].includes(status)) {
      return sendError(res, 400, { message: 'Invalid status' });
    }

    const message = await Message.findById(messageId);
    if (!message) {
      return res.status(404).json({
        success: false,
        message: 'Message not found',
      });
    }

    if (!message || message.type !== 'video_call') {
      return res.status(404).json({
        success: false,
        message: 'Video call message not found',
      });
    }

    if (message.videoCall) {
      message.videoCall.status = status;
      if (status === 'ended' && duration) {
        message.videoCall.duration = duration;
        message.videoCall.endedAt = new Date();
      }
    }

    await message.save();

    // Log activity
    await UserActivity.logActivity(req.user.id, 'video_call', {
      messageId,
      status,
      duration: duration || 0,
    });

    return sendSuccess(res, 200, { message: 'Video call status updated', data: message.videoCall });
  } catch (/** @type {any} */ error) {
    logger.error('Error updating video call status:', { error: error.message, stack: error.stack });
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : String(error),
    });
  }
};

/**
 * Get popular GIFs (integration with Giphy API)
 */
const getPopularGifs = async (req, res) => {
  try {
    const { limit = 20, offset = 0 } = req.query;

    // In production, integrate with Giphy API
    // For now, return mock data
    const mockGifs = [
      {
        id: 'gif1',
        url: 'https://media.giphy.com/media/example1.gif',
        title: 'Happy',
      },
      {
        id: 'gif2',
        url: 'https://media.giphy.com/media/example2.gif',
        title: 'Love',
      },
      // ... more GIFs
    ];

    return res.status(200).json({
      success: true,
      data: {
        gifs: mockGifs,
        limit: parseInt(limit),
        offset: parseInt(offset),
      },
    });
  } catch (/** @type {any} */ error) {
    logger.error('Error getting GIFs:', { error: error.message, stack: error.stack });
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : String(error),
    });
  }
};

/**
 * Search GIFs (Giphy API integration)
 */
const searchGifs = async (req, res) => {
  try {
    const { query, limit = 20, offset = 0 } = req.query;

    if (!query) {
      return sendError(res, 400, { message: 'Search query is required' });
    }

    // In production, call Giphy API
    // For now, return mock data
    const mockResults = [
      {
        id: 'gif_search_1',
        url: 'https://media.giphy.com/media/example_search_1.gif',
        title: `Search result for: ${query}`,
      },
    ];

    return res.status(200).json({
      success: true,
      data: {
        gifs: mockResults,
        query,
        limit: parseInt(limit),
        offset: parseInt(offset),
      },
    });
  } catch (/** @type {any} */ error) {
    logger.error('Error searching GIFs:', { error: error.message, stack: error.stack });
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : String(error),
    });
  }
};

/**
 * Get available sticker packs
 */
const getStickerPacks = async (req, res) => {
  try {
    // In production, manage sticker packs in database
    const mockPacks = [
      {
        id: 'pack1',
        name: 'Hearts',
        stickers: [
          { id: 's1', url: 'https://stickers.example.com/heart1.png' },
          { id: 's2', url: 'https://stickers.example.com/heart2.png' },
        ],
      },
      {
        id: 'pack2',
        name: 'Emojis',
        stickers: [
          { id: 's3', url: 'https://stickers.example.com/emoji1.png' },
          { id: 's4', url: 'https://stickers.example.com/emoji2.png' },
        ],
      },
    ];

    return res.status(200).json({
      success: true,
      data: {
        packs: mockPacks,
      },
    });
  } catch (/** @type {any} */ error) {
    logger.error('Error getting sticker packs:', { error: error.message, stack: error.stack });
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : String(error),
    });
  }
};

module.exports = {
  sendGifMessage,
  sendStickerMessage,
  sendVoiceMessage,
  transcribeVoiceMessage,
  initiateVideoCall,
  updateVideoCallStatus,
  getPopularGifs,
  searchGifs,
  getStickerPacks,
};
